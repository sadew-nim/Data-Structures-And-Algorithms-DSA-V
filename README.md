# Sorting Algorithms in Python

This repository contains implementations of commonly used **sorting algorithms** written in **Python**.  
These algorithms are essential for understanding **Data Structures & Algorithms (DSA)** and are widely used in software development.

---

## üìå Algorithms Included

1. Optimized Insertion Sort  
2. Selection Sort  
3. Merge Sort  
4. Quick Sort  

---

## 1Ô∏è‚É£ Optimized Insertion Sort

### Description
Insertion Sort works by building the sorted array one item at a time.  
The optimized version reduces unnecessary comparisons by stopping once the correct position is found.

### Time Complexity
- Best Case: **O(n)**
- Average Case: **O(n¬≤)**
- Worst Case: **O(n¬≤)**

### Space Complexity
- **O(1)** (In-place)

---

## 2Ô∏è‚É£ Selection Sort

### Description
Selection Sort repeatedly finds the minimum element from the unsorted part and places it at the beginning.

### Time Complexity
- Best Case: **O(n¬≤)**
- Average Case: **O(n¬≤)**
- Worst Case: **O(n¬≤)**

### Space Complexity
- **O(1)** (In-place)

---

## 3Ô∏è‚É£ Merge Sort

### Description
Merge Sort is a **Divide and Conquer** algorithm that divides the array into halves, sorts them, and then merges them back together.

### Time Complexity
- Best Case: **O(n log n)**
- Average Case: **O(n log n)**
- Worst Case: **O(n log n)**

### Space Complexity
- **O(n)**

---

## 4Ô∏è‚É£ Quick Sort

### Description
Quick Sort selects a **pivot element** and partitions the array into elements smaller and larger than the pivot, then recursively sorts the partitions.

### Time Complexity
- Best Case: **O(n log n)**
- Average Case: **O(n log n)**
- Worst Case: **O(n¬≤)**

### Space Complexity
- **O(log n)** (Recursive stack)

---

